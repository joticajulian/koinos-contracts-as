diff --git a/node_modules/@koinos/sdk-as/assembly/checkauthority.ts b/node_modules/@koinos/sdk-as/assembly/checkauthority.ts
new file mode 100644
index 0000000..03bd702
--- /dev/null
+++ b/node_modules/@koinos/sdk-as/assembly/checkauthority.ts
@@ -0,0 +1,97 @@
+import { Writer, Reader } from "as-proto";
+
+export namespace checkauthority {
+  export class checkauthority_args {
+    static encode(message: checkauthority_args, writer: Writer): void {
+      const unique_name_account = message.account;
+      if (unique_name_account !== null) {
+        writer.uint32(10);
+        writer.bytes(unique_name_account);
+      }
+
+      if (message.type != 0) {
+        writer.uint32(16);
+        writer.int32(message.type);
+      }
+
+      const unique_name_caller = message.caller;
+      if (unique_name_caller !== null) {
+        writer.uint32(26);
+        writer.bytes(unique_name_caller);
+      }
+
+      if (message.entry_point != 0) {
+        writer.uint32(32);
+        writer.uint32(message.entry_point);
+      }
+
+      const unique_name_data = message.data;
+      if (unique_name_data !== null) {
+        writer.uint32(42);
+        writer.bytes(unique_name_data);
+      }
+    }
+
+    static decode(reader: Reader, length: i32): checkauthority_args {
+      const end: usize = length < 0 ? reader.end : reader.ptr + length;
+      const message = new checkauthority_args();
+
+      while (reader.ptr < end) {
+        const tag = reader.uint32();
+        switch (tag >>> 3) {
+          case 1:
+            message.account = reader.bytes();
+            break;
+
+          case 2:
+            message.type = reader.int32();
+            break;
+
+          case 3:
+            message.caller = reader.bytes();
+            break;
+
+          case 4:
+            message.entry_point = reader.uint32();
+            break;
+
+          case 5:
+            message.data = reader.bytes();
+            break;
+
+          default:
+            reader.skipType(tag & 7);
+            break;
+        }
+      }
+
+      return message;
+    }
+
+    account: Uint8Array | null;
+    type: authorization_type;
+    caller: Uint8Array | null;
+    entry_point: u32;
+    data: Uint8Array | null;
+
+    constructor(
+      account: Uint8Array | null = null,
+      type: authorization_type = 0,
+      caller: Uint8Array | null = null,
+      entry_point: u32 = 0,
+      data: Uint8Array | null = null
+    ) {
+      this.account = account;
+      this.type = type;
+      this.caller = caller;
+      this.entry_point = entry_point;
+      this.data = data;
+    }
+  }
+
+  export enum authorization_type {
+    contract_call = 0,
+    transaction_application = 1,
+    contract_upload = 2,
+  }
+}
diff --git a/node_modules/@koinos/sdk-as/assembly/systemCalls.ts b/node_modules/@koinos/sdk-as/assembly/systemCalls.ts
index 5d14d99..e0cd54f 100644
--- a/node_modules/@koinos/sdk-as/assembly/systemCalls.ts
+++ b/node_modules/@koinos/sdk-as/assembly/systemCalls.ts
@@ -3,6 +3,7 @@ import { Protobuf, Reader, Writer } from 'as-proto';
 import { system_calls, system_call_ids, chain, protocol, authority, value, error, name_service } from '@koinos/proto-as';
 import { StringBytes } from ".";
 import { Base58 } from "./util";
+import { checkauthority } from "./checkauthority";
 
 export namespace System {
   export const DEFAULT_MAX_BUFFER_SIZE = 1024;
@@ -783,11 +784,14 @@ export namespace System {
   }
 
   /**
-    * Check authority for an account
+    * Check authority for an account (not secure, it is recommended to use
+    * System.checkCallContractAuthority or System.checkAuthority2)
     * @param type type of authority required
     * @param account account to check
+    * @param data data to be passed
     * @returns bool true if the account has authority
     * @example
+    * @deprecated
     * ```ts
     * System.checkAuthority(authority.authorization_type.transaction_application, Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe));
     * ```
@@ -802,6 +806,64 @@ export namespace System {
     return result.value;
   }
 
+  /**
+   * Check authority for an account
+   * @param type type of authority required
+   * @param account account to check
+   * @param data data to be passed
+   * @param caller caller of the current contract
+   * @param entryPoint entry point triggered in the current contract
+   * @returns bool true if the account has authority
+   * @example
+   * ```ts
+   * const args = System.getArguments();
+   * const caller = System.getCaller();
+   * const isAuthorized = System.checkAuthority2(
+   *   authority.authorization_type.contract_call,
+   *   Base58.decode("1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe"),
+   *   args.args,
+   *   caller.caller,
+   *   args.entry_point
+   * );
+   * ```
+   */
+  export function checkAuthority2(type: authority.authorization_type, account: Uint8Array, data: Uint8Array | null = null, caller: Uint8Array | null = null, entryPoint: u32 = 0): bool {
+    const args = new checkauthority.checkauthority_args(account, type, caller, entryPoint, data);
+    const encodedArgs = Protobuf.encode(args, checkauthority.checkauthority_args.encode);
+
+    // TODO: Add 607 system call to koinos-proto
+    const retcode = env.invokeSystemCall(607, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);
+    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));
+    const result = Protobuf.decode<system_calls.check_authority_result>(SYSTEM_CALL_BUFFER, system_calls.check_authority_result.decode, RETURN_BYTES[0]);
+    return result.value;
+  }
+
+  /**
+   * Check authority for an account using call_contract type.
+   * It takes care of filling the caller, data, and entry point. If you
+   * already consulted the caller, data, or entry point to the chain
+   * consider using System.checkAuthority2 to optimize your code.
+   * @param account account to check
+   * @returns bool true if the account has authority
+   * @example
+   * ```ts
+   * const isAuthorized = System.checkCallContractAuthority(
+   *   Base58.decode("1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe"),
+   * );
+   * ```
+   */
+  export function checkCallContractAuthority(account: Uint8Array): bool {
+    const args = getArguments();
+    const caller = getCaller();
+    return checkAuthority2(
+      authority.authorization_type.contract_call,
+      account,
+      args.args,
+      caller.caller,
+      args.entry_point
+    );
+  }
+
   /**
    * Require authority for an account
    * @param type type of authority required
